les images EpreuveImageEntity / ParkourImageEntity : 
  -> ne pas les create en même temps que les entity avec EpreuveCreateEntity / ParkourCreateEntity
  -> on les uploads avec le service image
    -> on met le lien + l'id_epreuve / id_parkour dans la bdd image_epreuve/ image_parkour
  => on pourra les reprendre normalement avec apollo


relier les epreuves aux parkours :
  -> dans la partie admin des parkours, y'a une recherche sur les epreuves
    -> on voie juste le nom
    -> on envoie juste les id pour la création / modification des epreuves


pour ModifyParkour => 
  pour les epreuves => [1,2,5]
  rien modifier => null
  enlever tout => []


on ne peux pas supprimer une epreuve si elle est relier à un parkour
on peux supprimer un parkour si y'a une relation avec epreuve, ça supprime aussi les relations

pas de tri par NOUVEAU, des annonces en haut de page ?

------------------------------------------------------------------------------------------------------

https://api-adresse.data.gouv.fr/search/?q=caen&postcode=14000&type=municipality

resolver => ce qui va etre utilisé à partir du front
service => utiliser à partir du back

------------------------------------------------------------------------------------------------------

    CLIENT    |    ADMIN     | NON CONNECTE
--------------|--------------|-------------
page profil   | page profil  |  
favoris       | options      |
note          |              |
options       |              |

------------------------------------------------------------------------------------------------------

Pour les images de couverture => 
    un seul isCouverture possible par parkour,
    en front on regarde si il y a un true 
        on met celui qui est à true
        si pas de true on s'en fout

------------------------------------------------------------------------------------------------------

vérifier enlevage de note quand on supp un user
  - enlève les notes au parkour ?
  - rien sur la note du parkour ?

------------------------------------------------------------------------------------------------------

DROP TABLE epreuve;
DROP TABLE image_epreuve;
DROP TABLE parkour;
DROP TABLE image_parkour;
DROP TABLE join_parkour_epreuve;

DROP TABLE user;
DROP TABLE join_user_parkour_favoris;
DROP TABLE join_user_parkour_note;
DROP TABLE report
DROP TABLE reset_password

------------------------------------------------------------------------------------------------------

message sur logout

------------------------------------------------------------------------------------------------------

- image parkour/epreuve isCouverture v2
- les liens google avec multer => couper le vrai nom du fichier (length=150)
- image profil default

------------------------------------------------------------------------------------------------------

@Column({ length: 1000 }):
Ce décorateur est spécifique à TypeORM.
Il définit la contrainte au niveau de la base de données.
Il indique à la base de données de limiter la longueur du champ à 1000 caractères.
Cela assure l'intégrité des données au niveau le plus bas, empêchant toute insertion de données dépassant cette limite, même si l'application le permettait.

@MaxLength(1000):
Ce décorateur vient de la bibliothèque class-validator.
Il ajoute une validation côté application.
Il permet de vérifier la longueur avant même d'essayer d'insérer les données dans la base.
Il est utile pour la validation des entrées utilisateur, par exemple dans les formulaires ou les API.

Pourquoi utiliser les deux ?
Sécurité en profondeur : Avoir une validation à plusieurs niveaux (application et base de données) renforce la sécurité et l'intégrité des données.
Performance : La validation côté application (@MaxLength) peut éviter des appels inutiles à la base de données pour des données invalides.
Flexibilité : La validation côté application peut être plus facilement personnalisée ou modifiée sans avoir à changer le schéma de la base de données.
Feedback utilisateur : Avec la validation côté application, vous pouvez fournir un retour immédiat à l'utilisateur sans avoir à interroger la base de données.
Cohérence : Cela garantit que les contraintes sont appliquées de manière cohérente, que les données passent par l'application ou qu'elles soient insérées directement dans la base de données.

------------------------------------------------------------------------------------------------------

J'ai ajouté ? après le type string pour indiquer que ces champs sont optionnels en TypeScript. Cela correspond mieux au fait que ces champs sont nullable dans GraphQL.

@IsOptional() : Cela indique que le champ peut être omis lors de la mise à jour. C'est important pour les mises à jour partielles.

------------------------------------------------------------------------------------------------------

@Field({ nullable: true })
Ce décorateur vient de TypeGraphQL.
Il définit la structure du schéma GraphQL.
Il indique que ce champ peut être null dans les requêtes et réponses GraphQL.
Il affecte la façon dont le champ est représenté dans le schéma GraphQL (il devient optionnel dans le schéma).

@IsOptional()
Ce décorateur vient de class-validator.
Il concerne la validation des données côté application.
Il indique que le champ peut être omis lors de la validation (c'est-à-dire qu'il peut être undefined).
Il n'affecte pas le schéma GraphQL, mais plutôt la logique de validation dans votre application.

------------------------------------------------------------------------------------------------------

Vous n'avez pas besoin d'ajouter des @JoinColumn pour ces relations @OneToMany.
@JoinColumn est généralement utilisé du côté "propriétaire" de la relation, qui est typiquement le côté "Many" dans une relation @ManyToOne.

TEST